# Motivation for RSocket-RPC

As many of us might know, there is an RPC project called gRPC. The gRPC project allows us easily setup RPC communication between several services. Even though the communication is reactive, asynchronous and non-blocking, the current implementation of gRPC does not allow to achieve one of the central goals for Reactive Streams - Backpressure control. At that moment, gRPC uses HTTP/2 as a transport and employee its flow control in order to achieve backpressure. HTTP/2 flow allows only byte-acknowledgment-based flow control, which means there is no specific part of the protocol that can say how many logical-elements a consumer ready to accept. That limitation may impact system stability under high-load which may be either performance degradation or resilience degradation.

Therefore, RSocket-RPC comes for rescue. The central idea of RSocket-RPC is to provide identical communication features as there are in gRPC. As we might remember, gRPC offers Protocol Buffer integration, which along with common data structures generation, allows generating stubs for services. The RSocket-RPC library employees the same techniques and provides the same plugin for stub generation. In turn, RSocket-RPC uses RSocket protocol as an application level transport for message exchange which includes out-of-the-box logical-elements-based backpressure control, therefore offers better resilience without impact on system's performance.

Also, RSocket-RPC is language agnostic and at the current moment provides integration with [JavaScript](https://github.com/rsocket/rsocket-rpc-js) as well as with [Java](https://github.com/rsocket/rsocket-rpc-java).